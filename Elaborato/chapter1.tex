\chapter{Algoritmi sequenziali}
Prima di avviarci nella teoria del calcolo parallelo è doverosa un'introduzione nel concetto del calcolo algoritmico sequenziale.\\
Molti dei concetti riguardanti la parallelizzazione del codice è un'estensione della sua controparte sequenziale e figlia delle sue ovvie limitazioni nell'ambito dell'esecuzione.\cite{Placeholder}\\
Solitamente quando pensiamo ad un algoritmo generico il nostro primo pensiero è quello di un programma atto ad essere eseguito su una macchina di Von Neuman, il più semplice e minimale modello di calcolatore, dotato di una singola CPU e che esegue una serie (finita) di istruzioni eseguite una dopo l'altra. Sequenzialità, dunque, significa prendere un problema e "spacchettarlo" in una sequenza di operazioni da eseguire da un singolo processore.\\
Poiché la nostra analisi è orientata principalmente allo studio della complessità algoritmica, ci concentreremo su un comodo modello di calcolo, specializzato in questo campo: la macchina di Turing.
\section{Macchina di Turing Deterministica}
La macchina di Turing (MdT) è un modello ideale di calcolatore dalle meccaniche intuitive e semplici, solitamente usato più per l'analisi computazionale che per l'implementazione di calcolatori reali. Vista la sua semplicità, rappresenta uno dei modelli più utilizzati per identificare e studiare il calcolo sequenziale.\\
Una MdT è composta essenzialmente da:
\begin{itemize}
\item{un'unità di controllo a stati finiti (deterministica, da cui il nome del titolo);}
\item{un nastro diviso in celle di dimensione arbitraria contenente i dati di input/output;}
\item{una testina capace di leggere, scrivere o cancellare dati sul suddetto nastro (inizialmente posizionata sulla cella più a sinistra del nastro).}
\end{itemize}
Analogamente l'esecuzione di una MdT è suddivisa nelle seguenti fasi:
\begin{itemize}
\item{inizialmente, trattandosi di un'automa a stati finiti, l'unità di controllo si trova in uno stato iniziale;}
\item{viene scritta su nastro la "stringa" di input;}
\item{a seconda dello stato corrente dell'unità di controllo e del carattere letto mediante la testina, la macchina si posiziona sullo stato successivo; da ciò dipende il comportamento della testina sulle operazioni su nastro (lettura, scrittura o nessuna operazione), comprese azioni di scorrimento sullo stesso;}
\item{l'esecuzione termina se viene letta un'operazione non riconosciuta o se l'unità di controllo ha raggiunto uno stato finale.}
\end{itemize}
La MdT ha avuto un ruolo fondamentale nell'informatica teorica: poiché è matematicamente dimostrato che per qualsiasi modello di calcolo esiste una macchina di Turing associata (tesi di Church-Turing), questo ha reso possibile definire uno standard nell'analisi computazionale degli algoritmi.
\subsection{Complessità sequenziale}
Quando analizziamo un algoritmo dobbiamo tenere in considerazione due caratteristiche: il fatto che risolva correttamente il problema che gli viene chiesto di risolvere (correttezza) e quante risorse impiega per essere eseguito (complessità).\\
La complessità di un algoritmo si basa essenzialmente su due misure esprimibili come $\mathrm{T}_{A}(x)$ e $\mathrm{M}_{A}(x)$, rispettivamente il tempo di calcolo e lo spazio utilizzati dall'algoritmo A su input \textit{x}. In ambito informatico l'efficienza di un algoritmo è basato essenzialmente sull'utilizzo che un algoritmo fa delle risorse della macchina: il tempo è correlato alla CPU e lo spazio dalla memoria.\\
Algoritmi aventi la stessa finalità possono non avere il medesimo utilizzo di tempo e memoria. Per questo motivo di parla di efficienza, per distinguere al meglio la qualità di un algoritmo rispetto ad un altro.\\
Misurare le caratteristiche di un algoritmo non è un concetto immediato come può sembrare. L'esecuzione di un programma su un calcolatore dipende sempre da numerosi fattori: la macchina usata, il linguaggio, il compilatore, ecc. Dunque è bene definire una stima \textbf{assoluta} di quella che è la complessità di un algoritmo.\\
Qui entra in gioco la macchina di Turing: dal momento che ogni algoritmo può essere tradotto in modo da poter essere eseguito su una MdT possiamo sfruttarla per ottenere stime temporali sotto forma di funzioni.
\subsubsection{Tempo}
In termini di tempo diciamo che un algoritmo A che opera su un generico input \textit{x} restituisce un risultato dopo un tempo $\mathrm{T}_{A}(x) = f(n)$, con \textit{n} pari alla lunghezza dell'input \textit{x} e \textit{f(n)} pari al numero totale di operazioni da eseguire (funzione dipendente dalle dimensioni dell'input).\\
In genere quando si tratta di efficienza di un algoritmo il tempo di esecuzione assume un ruolo primario rispetto alla memoria.
\subsubsection{Memoria}
In termini di spazio di memoria diciamo che un algoritmo A che opera su un generico input \textit{x} necessita di un numero di "celle" di memoria pari a $\mathrm{M}_{A}(x) = f(n)$, con \textit{n} pari alla lunghezza dell'input \textit{x}.
\subsection{Lato pratico}
Abbiamo appena derivato un metodo corretto per calcolare la complessità di un algoritmo. Sfortunatamente, in ambito reale, derivare correttamente la funzione che descrive l'utilizzo delle risorse di un algoritmo può rivelarsi un compito arduo. Oltretutto il fine ultimo del calcolo della complessità algoritmica è il confronto tra i vari algoritmi per capirne l'efficienza, dunque non è richiesta una stima esatta delle risorse utilizzate.\\
Per questo motivo si ricorre ad un metodo di misurazione più blando, ma comunque efficace, sfruttando la teoria del calcolo asintotico. Più precisamente ci affidiamo alla notazione $\mathcal{O}(n \log {}n)$ ("O grande") e a successioni di immediata comprensione per dare un'idea dell'efficienza dell'algoritmo rispetto a casi particolari di esecuzione. In particolare per ogni algoritmo riconosciamo le relative prestazioni nei seguenti casi:
\begin{itemize}
\item{caso ottimo: caso di esecuzione che richiede all'algoritmo meno operazioni per ottenere una soluzione;}
\item{caso peggiore: caso di esecuzione che richiede all'algoritmo il maggior numero possibile di operazioni per ottenere una soluzione;}
\item{caso medio: caso definito statisticamente; rappresenta un valore medio di operazioni che esegue l'algoritmo rispetto ad un numero sufficientemente grande di esecuzioni.}
\end{itemize}
Tra tutti i casi, ovviamente quello medio è l'elemento più utile ai fini del calcolo della complessità computazionale, poiché solitamente ci aspettiamo di eseguire un algoritmo su problemi generici.
\chapter{Esempi}
Di seguito verranno presentati alcuni esempi di algoritmi sequenziali, molti dei quali verranno implementati a livello di codice alla fine dell'elaborato.
\section{Ordinamento}
Quello dell'ordinamento di un insieme di oggetti confrontabili è uno degli problemi tipici del calcolo algoritmico. Ne esistono di diversi tipi, il che lo rende un esempio perfetto per confrontare le varie alternative.\\
Prendiamo ad esempio due algoritmi piuttosto comuni in questo campo: quicksort\footnote{In linguaggio naturale: preso un elemento \textit{x} in una lista, se ne creano due: quella degli elementi minori di \textit{x} e quella degli elementi maggiori. Si richiama poi l'algoritmo sulle nuove liste, dopodiché si uniscono i risultati aggiungendo \textit{x} in mezzo agli stessi.} e mergesort\footnote{In linguaggio naturale: è il tipico algoritmo divide-et-impera; una lista avente uno o nessun elemento è ordinata, altrimenti si divide la lista in input in due e si esegue mergesort su entrambe; alla fine si estrae dalle due liste (ordinate) il minore tra i valori in testa, fino ad esaurire tutti gli elementi presenti.}. In questo caso, ad esempio i vari casi di esecuzione cambiano:
\begin{itemize}
\item{caso migliore:  $\mathcal {O}(n \log {}n)$ per quicksort e  $\mathcal {O}(n \log {}n)$ per mergesort;}
\item{caso peggiore:  $\mathcal {O}(n^2)$ per quicksort e  $\mathcal {O}(n \log {}n)$ per mergesort;}
\item{caso medio:  $\mathcal {O}(n \log {}n)$ per quicksort e  $\mathcal {O}(n \log {}n)$ per mergesort;}
\end{itemize}
\subsubsection{Pseudocodice}
\begin{verbatim}
Quicksort(L = [a1,...,an])
    if(n <= 1) then
        return L
    else
        scegli un elemento "p" in L
	    calcola la lista "left" di elementi minori di p
	    calcola la lista "right" di elementi maggiori di p
	    left = Quicksort(left)
	    right = Quicksort(right)
	    return left : [p] : right


Mergesort(L = [a1,..,an])
    if(n <= 1) then
        return L
    else
        dividi la lista L a metà, creando le liste "left" e "right" 
        left = Mergesort(left)
        right = Mergesort(right)
        return merge(left, right)
        
merge(left, right)
    if(left = []) return right
    else if(right = []) return left
    else
        h1 = head(left)
        h2 = head(right)
        if (h1 < h2) then
            t = tail(left)
            return [h1] : merge(t, right)
        else
            t = tail(right)
            return [h2] : merge(left, t)
\end{verbatim}
\section{Algebra Lineare}
Facciamo degli esempi riguardanti le operazioni tra matrici:
\begin{itemize}
\item{prodotto tra matrici}
\item{calcolo del determinante}
\end{itemize}
Nel primo caso il prodotto di matrici è un operazione direttamente proporzionale alle dimensioni degli operandi. In caso di prodotto di una matrice MxN con una MxP sarà necessario un algoritmo di complessità asintotica  $\mathcal {O}(N*M*P)$.
\subsubsection{Pseudocodice}
\begin{verbatim}
Prodotto(A = matrice MxN, B = matrice NxP)
	C = matrice MxP di zeri
    for (i from 1 to M)
        for (j from 1 to P)
            for (k from 1 to N)
                c_ij = c_ij + (a_ik * b_kj)
            end for
        end for
    end for
    return C
\end{verbatim}

\section{Grafi}
